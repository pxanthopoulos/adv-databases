+---------+-----------+
|partofday|crime_total|
+---------+-----------+
|    night|     237605|
|  evening|     187306|
|afternoon|     148180|
|  morning|     123846|
+---------+-----------+

df - 56s
rdd - 78s

Difference by chatgpt:

The difference in execution times between RDDs and DataFrames can be attributed to the higher-level abstractions and optimizations provided by DataFrames compared to the lower-level nature of RDDs. Here are some factors that may contribute to the observed performance difference:

Query Optimization:

DataFrames leverage Spark's Catalyst Optimizer and Tungsten Execution Engine, which can perform advanced optimizations, such as predicate pushdown, constant folding, and code generation. These optimizations can lead to more efficient query execution plans.
Lazy Evaluation:

Both RDDs and DataFrames support lazy evaluation, but DataFrames often benefit from additional optimizations due to the higher-level abstractions. Catalyst can optimize the logical plan before it is converted into a physical plan.
Code Generation:

DataFrames use Tungsten's code generation to generate optimized bytecode for transformations and actions. This can result in more efficient execution compared to the row-wise processing of RDDs.
Catalyst Expression Trees:

Catalyst processes expressions in a tree-like fashion, allowing for advanced optimizations at the expression level. This can lead to better performance in DataFrames compared to RDDs.
Optimized Storage Formats:

DataFrames can take advantage of optimized storage formats like Parquet, which can significantly improve performance by allowing for predicate pushdown and efficient data compression.
Built-in Catalyst Functions:

DataFrames come with a rich set of built-in functions that are highly optimized. These functions often outperform user-defined functions applied to RDDs.
Structured Query Optimization:

DataFrames operate on structured data, and Spark can exploit the schema information to optimize queries further. This is not as straightforward with RDDs, which represent unstructured data.
To further investigate the performance difference:

Use the explain method on the DataFrame to inspect the physical execution plan and identify the optimizations applied.
Consider any transformations, actions, or operations that are specific to RDDs and may contribute to the longer execution time.
Evaluate the complexity of the operations performed using RDDs and assess whether similar operations can be achieved more efficiently with DataFrames.
In general, while RDDs provide lower-level control, DataFrames offer a higher level of abstraction with built-in optimizations for a wide range of operations, resulting in better performance for many use cases.